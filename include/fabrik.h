/* Fabrik Cache C API
 *
 * Thread-safe C API for integrating Fabrik cache into external toolchains.
 *
 * ## Example Usage
 *
 * ```c
 * #include "fabrik.h"
 * #include <stdio.h>
 *
 * int main() {
 *     // Initialize cache
 *     FabrikCache *cache = fabrik_cache_init("/tmp/fabrik-cache");
 *     if (!cache) {
 *         fprintf(stderr, "Failed to initialize cache: %s\n", fabrik_last_error());
 *         return 1;
 *     }
 *
 *     // Store artifact
 *     const char *data = "Hello, World!";
 *     const char *hash = "abc123def456";
 *     if (fabrik_cache_put(cache, hash, (const uint8_t*)data, 13) != FABRIK_OK) {
 *         fprintf(stderr, "Failed to put: %s\n", fabrik_last_error());
 *     }
 *
 *     // Check existence
 *     int exists = 0;
 *     if (fabrik_cache_exists(cache, hash, &exists) == FABRIK_OK) {
 *         printf("Artifact exists: %d\n", exists);
 *     }
 *
 *     // Retrieve artifact
 *     uint8_t buffer[1024];
 *     size_t bytes_read = 0;
 *     if (fabrik_cache_get(cache, hash, buffer, sizeof(buffer), &bytes_read) == FABRIK_OK) {
 *         printf("Retrieved %zu bytes\n", bytes_read);
 *     }
 *
 *     // Cleanup
 *     fabrik_cache_free(cache);
 *     return 0;
 * }
 * ```
 *
 * ## Memory Management
 *
 * - All cache handles must be freed with `fabrik_cache_free()`
 * - Error strings are owned by the library and should not be freed
 * - All functions are thread-safe
 *
 * ## Error Handling
 *
 * All functions return error codes. Use `fabrik_last_error()` to get
 * the error message for the current thread.
 *
 * Copyright (c) 2025 Tuist GmbH
 * Licensed under MIT License
 */

#ifndef FABRIK_H
#define FABRIK_H

#pragma once

/* Generated with cbindgen:0.29.2 */

/* Warning: This file is auto-generated by cbindgen. Do not modify. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

/*
 Result codes
 */
#define FabrikFABRIK_OK 0

#define FabrikFABRIK_ERROR -1

#define FabrikFABRIK_ERROR_NOT_FOUND -2

#define FabrikFABRIK_ERROR_INVALID_HASH -3

#define FabrikFABRIK_ERROR_IO -4

/*
 Filesystem-based storage with RocksDB metadata tracking

 Layout:
 - `.fabrik/cache/objects/ab/cd1234...` - Content-addressed blob storage (first 2 chars = subdir)
 - `.fabrik/cache/metadata/` - RocksDB database for access tracking and eviction

 Optimizations:
 - RocksDB provides concurrent reads/writes out of the box
 - Async batched access tracking (touch operations)
 - Snappy compression for metadata
 - Column families for efficient indexing (LRU/LFU eviction)
 */
typedef struct FabrikFilesystemStorage FabrikFilesystemStorage;

/*
 Opaque handle to a Fabrik cache instance
 */
typedef struct FabrikFabrikCache {
    struct FabrikFilesystemStorage storage;
} FabrikFabrikCache;

/*
 Initialize a new Fabrik cache instance

 # Arguments
 * `cache_dir` - Path to cache directory (NULL-terminated C string)

 # Returns
 * Pointer to FabrikCache on success
 * NULL on error (use `fabrik_last_error()` to get error message)

 # Safety
 * `cache_dir` must be a valid NULL-terminated C string
 * Returned pointer must be freed with `fabrik_cache_free()`
 */
fabrik_ struct FabrikFabrikCache *fabrik_cache_init(const char *aCacheDir);

/*
 Free a Fabrik cache instance

 # Safety
 * `cache` must be a valid pointer returned by `fabrik_cache_init()`
 * Must not be used after calling this function
 */
fabrik_ void fabrik_cache_free(struct FabrikFabrikCache *aCache);

/*
 Get an artifact from the cache

 # Arguments
 * `cache` - Cache instance
 * `hash` - Content hash (NULL-terminated C string)
 * `output_buffer` - Buffer to write data (must be pre-allocated)
 * `buffer_size` - Size of output buffer
 * `bytes_written` - Output: actual bytes written

 # Returns
 * `FABRIK_OK` on success
 * `FABRIK_ERROR_NOT_FOUND` if artifact not found
 * `FABRIK_ERROR` on other errors

 # Safety
 * All pointers must be valid
 * `output_buffer` must have at least `buffer_size` bytes allocated
 */
fabrik_
int fabrik_cache_get(struct FabrikFabrikCache *aCache,
                     const char *aHash,
                     uint8_t *aOutputBuffer,
                     uintptr_t aBufferSize,
                     uintptr_t *aBytesWritten);

/*
 Put an artifact into the cache

 # Arguments
 * `cache` - Cache instance
 * `hash` - Content hash (NULL-terminated C string)
 * `data` - Data to store
 * `data_len` - Length of data in bytes

 # Returns
 * `FABRIK_OK` on success
 * `FABRIK_ERROR` on error

 # Safety
 * All pointers must be valid
 * `data` must have at least `data_len` bytes
 */
fabrik_
int fabrik_cache_put(struct FabrikFabrikCache *aCache,
                     const char *aHash,
                     const uint8_t *aData,
                     uintptr_t aDataLen);

/*
 Check if an artifact exists in the cache

 # Arguments
 * `cache` - Cache instance
 * `hash` - Content hash (NULL-terminated C string)
 * `exists` - Output: 1 if exists, 0 if not

 # Returns
 * `FABRIK_OK` on success
 * `FABRIK_ERROR` on error

 # Safety
 * All pointers must be valid
 */
fabrik_ int fabrik_cache_exists(struct FabrikFabrikCache *aCache, const char *aHash, int *aExists);

/*
 Delete an artifact from the cache

 # Arguments
 * `cache` - Cache instance
 * `hash` - Content hash (NULL-terminated C string)

 # Returns
 * `FABRIK_OK` on success
 * `FABRIK_ERROR` on error

 # Safety
 * All pointers must be valid
 */
fabrik_ int fabrik_cache_delete(struct FabrikFabrikCache *aCache, const char *aHash);

/*
 Get the last error message

 # Returns
 * Pointer to NULL-terminated error string
 * NULL if no error

 # Safety
 * Returned string is valid until next API call
 * Do not free the returned pointer
 */
fabrik_ const char *fabrik_last_error(void);

/*
 Free a string allocated by the Fabrik library

 # Safety
 * `s` must be a string allocated by a Fabrik API function
 */
fabrik_ void fabrik_free_string(char *aS);

/*
 Get the library version

 # Returns
 * Pointer to NULL-terminated version string

 # Safety
 * Returned string is statically allocated, do not free
 */
fabrik_ const char *fabrik_version(void);

#endif  /* FABRIK_H */
