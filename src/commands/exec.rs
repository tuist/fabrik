use anyhow::{Context, Result};
use std::process::Stdio;
use std::sync::Arc;
use tokio::process::Command;
use tracing::info;

use crate::bazel::proto::bytestream::byte_stream_server::ByteStreamServer;
use crate::bazel::proto::remote_execution::action_cache_server::ActionCacheServer;
use crate::bazel::proto::remote_execution::capabilities_server::CapabilitiesServer;
use crate::bazel::proto::remote_execution::content_addressable_storage_server::ContentAddressableStorageServer;
use crate::bazel::{
    BazelActionCacheService, BazelByteStreamService, BazelCapabilitiesService, BazelCasService,
};
use crate::cli::ExecArgs;
use crate::config_discovery::populate_build_tool_env_vars;
use crate::eviction::{spawn_background_eviction, BackgroundEvictionConfig, EvictionConfig};
use crate::http::HttpServer;
use crate::merger::MergedExecConfig;
use crate::storage;
use tonic::transport::Server;

pub async fn run(args: ExecArgs) -> Result<()> {
    use crate::config_discovery::load_config_with_discovery;

    if args.command.is_empty() {
        anyhow::bail!("No command specified. Usage: fabrik exec -- <command>");
    }

    // Load config file with auto-discovery
    let file_config = load_config_with_discovery(args.config.as_deref())?;

    // Merge configuration
    let config = MergedExecConfig::merge(&args, file_config);

    info!("Starting Fabrik exec mode");
    info!("Configuration:");
    info!("  Cache directory: {}", config.cache_dir);
    info!("  Max cache size: {}", config.max_cache_size);
    info!("  Upstream: {:?}", config.upstream);

    // Initialize eviction configuration from merged config
    let eviction_config = EvictionConfig::from_cache_config(
        &config.max_cache_size,
        &config.eviction_policy,
        &config.default_ttl,
    )?;

    // Initialize shared storage backend with eviction
    let storage =
        storage::create_storage_with_eviction(&config.cache_dir, eviction_config.clone())?;
    let storage = Arc::new(storage);

    // Spawn background eviction task
    let eviction_handle = {
        let bg_config = BackgroundEvictionConfig::from_eviction_config(eviction_config);
        spawn_background_eviction(storage.clone(), bg_config)
    };
    info!("Background eviction task started");

    // Start HTTP server (for Metro, Gradle, Nx, TurboRepo)
    let http_storage = storage.clone();
    let (http_server, http_port, http_listener) =
        HttpServer::new_with_port_zero(http_storage).await?;

    info!("HTTP cache server bound to port {}", http_port);

    let http_handle =
        tokio::spawn(async move { http_server.run_with_listener(http_listener).await });

    // Start gRPC server (for Bazel)
    let grpc_storage = storage.clone();
    let listener = tokio::net::TcpListener::bind("127.0.0.1:0").await?;
    let grpc_port = listener.local_addr()?.port();
    let addr: std::net::SocketAddr = format!("127.0.0.1:{}", grpc_port).parse().unwrap();
    drop(listener);

    info!("Starting gRPC cache server on port {}", grpc_port);

    let grpc_handle = tokio::spawn(async move {
        let action_cache = BazelActionCacheService::new(grpc_storage.clone());
        let cas = BazelCasService::new(grpc_storage.clone());
        let bytestream = BazelByteStreamService::new(grpc_storage.clone());
        let capabilities = BazelCapabilitiesService::new();

        info!("gRPC server listening on 127.0.0.1:{}", addr.port());

        Server::builder()
            .add_service(ActionCacheServer::new(action_cache))
            .add_service(ContentAddressableStorageServer::new(cas))
            .add_service(ByteStreamServer::new(bytestream))
            .add_service(CapabilitiesServer::new(capabilities))
            .serve(addr)
            .await
            .map_err(|e| anyhow::anyhow!("gRPC server error: {}", e))
    });

    // Build environment variables
    let mut env_vars = std::collections::HashMap::new();

    // Generate temporary bazelrc file for zero-config Bazel support
    let bazelrc_path =
        std::env::temp_dir().join(format!("fabrik-exec-{}.bazelrc", std::process::id()));
    let grpc_url_str = format!("grpc://127.0.0.1:{}", grpc_port);
    let bazelrc_content = format!(
        "# Auto-generated by Fabrik exec\n\
         # Temporary file for this execution\n\
         #\n\
         # Remote cache configuration\n\
         build --remote_cache={}\n\
         test --remote_cache={}\n",
        grpc_url_str, grpc_url_str
    );
    std::fs::write(&bazelrc_path, bazelrc_content)
        .with_context(|| format!("Failed to write bazelrc: {}", bazelrc_path.display()))?;

    // Always export BAZELRC for zero-config Bazel support
    env_vars.insert("BAZELRC".to_string(), bazelrc_path.display().to_string());

    if args.export_env {
        let prefix = &args.env_prefix;
        env_vars.insert(
            format!("{}HTTP_URL", prefix),
            format!("http://127.0.0.1:{}", http_port),
        );
        env_vars.insert(
            format!("{}GRPC_URL", prefix),
            format!("grpc://127.0.0.1:{}", grpc_port),
        );

        // Build tool environment variables (Gradle, Nx, Xcode, TurboRepo, etc.)
        let build_tool_vars = populate_build_tool_env_vars(
            format!("http://127.0.0.1:{}", http_port),
            format!("grpc://127.0.0.1:{}", grpc_port),
            None, // exec mode doesn't use unix sockets
        );
        for (key, value) in build_tool_vars {
            if key == "TURBO_TEAM" || key == "TURBO_TOKEN" {
                info!("Auto-generated {} for local development", key);
            }
            env_vars.insert(key, value);
        }

        info!("Exported environment variables:");
        for (key, value) in &env_vars {
            info!("  {}={}", key, value);
        }
    }

    // Execute user command
    info!("Executing command: {}", args.command.join(" "));

    let mut cmd = Command::new(&args.command[0]);
    cmd.args(&args.command[1..])
        .stdin(Stdio::inherit())
        .stdout(Stdio::inherit())
        .stderr(Stdio::inherit());

    // Set environment variables
    for (key, value) in &env_vars {
        cmd.env(key, value);
    }

    let status = cmd
        .status()
        .await
        .with_context(|| format!("Failed to execute command: {}", args.command[0]))?;

    info!("Command completed with status: {}", status);

    // Cleanup temporary bazelrc file
    if bazelrc_path.exists() {
        let _ = std::fs::remove_file(&bazelrc_path);
    }

    // Shutdown servers
    info!("Shutting down cache servers...");
    http_handle.abort();
    grpc_handle.abort();

    // Shutdown background eviction task
    info!("Shutting down background eviction task...");
    eviction_handle.shutdown().await;

    // Give them a moment to cleanup
    tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;

    if !status.success() {
        std::process::exit(status.code().unwrap_or(1));
    }

    Ok(())
}
